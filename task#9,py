#Example:
#In OOP, we have the flexibility to represent real world objects(animals, cars, person etc). Overall, an object is something that possess some of the characteristics and can-do certain functions.
class bestcar:
    
    # attributes
        year = 1999     # car model's year
        mpg =  25       # mileage
        speed = 255     # today` speed
        
    # methods
        def faster(self):
            return car.speed + 20

        def slower(self):
            return car.speed - 50

#As we stated earlier, functional programming is pure.
#We may start coding in a more practical way without any special Python features or libraries.
#If you would like functions to be pure, then do not alter the input value or other data that occurs beyond the meaning of the function.
#This makes it far smoother to test the work we write. As it doesn't change the state of any element, 
#any time we run the function with the same input, we are guaranteed to get the same output.

#Let's create a pure-function to multiply numbers by3:
def multiply_3_pure(numbers):    #we will create a function which multiplies numbers by 3 
    new_numbers = [] 		#it is empty for now
    for n in numbers: 
        new_numbers.append(n * 3) #now,  3 will be multiplied to each of the number in the list 
    return new_numbers 

original_numbers = [1, 3, 5, 10] 	#original set of numbers
changed_numbers = multiply_3_pure(original_numbers)
print(original_numbers) # [1, 3, 5, 10] 
print(changed_numbers) # [3, 9, 15, 30]

#The original set of numbers is unchanged, and outside of the function, we do not apply to any other variables, so it is pure.
